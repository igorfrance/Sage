// <auto-generated>Marked as auto-generated so StyleCop will ignore BDD style tests</auto-generated>
/**
 * Open Source Initiative OSI - The MIT License (MIT):Licensing
 * [OSI Approved License]
 * The MIT License (MIT)
 *
 * Copyright (c) 2011 Igor France
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
namespace Kelp.Test.ResourceHandling
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.IO;
	using System.Threading;

	using Kelp.ResourceHandling;
	using Machine.Specifications;

	[Subject(typeof(ScriptFile)), Tags(Categories.ResourceHandling)]
	public class When_getting_an_including_file
	{
		private static string content;
		private static CodeFile subject;

		private Establish context = () =>
			{
				subject = CreateInstance();
				Utilities.ClearTemporaryDirectory();
				content = subject.Content;
			};

		private It Should_contain_included_file1 = () => content.ShouldContain("Test.ExampleClass1");
		private It Should_contain_included_file2 = () => content.ShouldContain("Test.ExampleClass2");
		private It Should_contain_included_file3 = () => content.ShouldContain("Test.ExampleClass3");
		private It Should_save_the_resulting_file_to_cache = () => File.Exists(subject.CacheName).ShouldBeTrue();
		private It Should_include_files_in_proper_order = () =>
			{
				IEnumerable<string> keys = subject.References.Keys;
				keys.ElementAt(0).ShouldContain("include1");
				keys.ElementAt(1).ShouldContain("include3");
				keys.ElementAt(2).ShouldContain("include2");
				keys.ElementAt(3).ShouldContain("script1");
			};
		private It Should_preserve_the_correct_include_after_files_change = () =>
		{
			IEnumerable<string> keys = subject.References.Keys;
			keys.ElementAt(0).ShouldContain("include1");
			keys.ElementAt(1).ShouldContain("include3");
			keys.ElementAt(2).ShouldContain("include2");
			keys.ElementAt(3).ShouldContain("script1");

			CreateInstance().IsFromCache.ShouldBeTrue();

			string scriptPath = Utilities.GetScriptPath("include2.js");
			File.SetLastWriteTime(scriptPath, DateTime.Now);
			Thread.Sleep(500);

			CodeFile other = CreateInstance();
			other.IsFromCache.ShouldBeFalse();

			IEnumerable<string> keys2 = other.References.Keys;
			keys2.ElementAt(0).ShouldContain("include1");
			keys2.ElementAt(1).ShouldContain("include3");
			keys2.ElementAt(2).ShouldContain("include2");
			keys2.ElementAt(3).ShouldContain("script1");
		};
		private static CodeFile CreateInstance()
		{
			return CodeFile.Create(Utilities.GetScriptPath("script1.js"), "script1.js", Utilities.MapPath);
		}
	}

	[Subject(typeof(ScriptFile)), Tags(Categories.ResourceHandling)]
	public class When_getting_a_file_with_indirect_self_inclusion
	{
		private static string content;
		private static ScriptFile subject = (ScriptFile)
				CodeFile.Create(Utilities.GetScriptPath("script2.js"), "script2.js", Utilities.MapPath);

		private It Should_throw_an_InvalidOperationException = () =>
			Catch.Exception(() => content = subject.Content).ShouldBeOfType<InvalidOperationException>();
	}

	[Subject(typeof(ScriptFile)), Tags(Categories.ResourceHandling)]
	public class When_getting_a_file_with_includes_itself
	{
		private static string content;
		private static ScriptFile subject = (ScriptFile)
				CodeFile.Create(Utilities.GetScriptPath("script3.js"), "script3.js", Utilities.MapPath);

		private It Should_throw_an_InvalidOperationException = () =>
			Catch.Exception(() => content = subject.Content).ShouldBeOfType<InvalidOperationException>();
	}

	[Subject(typeof(ScriptFile)), Tags(Categories.ResourceHandling)]
	public class When_minifying_script_files
	{
		private static ScriptFile subject = (ScriptFile) CodeFile.Create(
			Utilities.GetScriptPath("compression1.js"), "compression.js", Utilities.MapPath);

		private It Multiline_strings_should_be_concatenated = () =>
			subject.Minify(Utilities.GetScriptContents("multiline-string1.js")).ShouldNotContain("\n");

		private It Multiline_strings_with_backslash_syntax_should_not_result_in_errors = () =>
			subject.Minify(Utilities.GetScriptContents("multiline-string2.js")).ShouldNotContain("\n");

		private It Should_remove_whitespace_from_expressions = () =>
			subject.Minify(Utilities.GetScriptContents("formatting3.js")).ShouldContain("8/12+4");

		private It Should_not_remove_whitespace_from_regex = () =>
			subject.Minify(Utilities.GetScriptContents("formatting3.js")).ShouldContain("/12  87/");

		private It Should_not_remove_whitespace_from_regex_function_call = () =>
			subject.Minify(Utilities.GetScriptContents("formatting3.js")).ShouldContain("callFx(/6 \\//)");

		private It Should_not_remove_whitespace_from_negated_regex_expression = () =>
			subject.Minify(Utilities.GetScriptContents("formatting3.js")).ShouldContain("MSIE (5");
	}

	[Subject(typeof(ScriptFile)), Tags(Categories.ResourceHandling)]
	public class When_getting_a_file_that_exists_in_cache_already
	{
		private static string scriptName = "script1.js";
		private static string scriptPath = Utilities.GetScriptPath(scriptName);
		private static string contents;
		private static ScriptFile subject;

		private Establish ctx = () =>
		{
			Utilities.ClearTemporaryDirectory();

			subject = new ScriptFile(scriptPath, scriptName, Utilities.MapPath);
			contents = subject.Content;
		};

		private It Should_use_cached_file_as_long_an_it_is_newer_than_original = () =>
		{
			// this will ensure the cached file is newer than original
			using (StreamWriter writer = File.AppendText(subject.CacheName))
			{
				writer.WriteLine("Cached line");
				writer.Close();
			}

			new ScriptFile(scriptPath, scriptName, Utilities.MapPath).Content.ShouldContain("Cached line");
		};

		private It Should_use_original_instead_of_cache_file_if_original_was_changed = () =>
		{
			File.SetLastWriteTime(scriptPath, DateTime.Now);
			File.SetLastWriteTime(subject.CacheName, DateTime.Now.AddDays(-1));
			Thread.Sleep(1000);

			new ScriptFile(scriptPath, scriptName, Utilities.MapPath).Content.ShouldNotContain("Cached line");
		};
	}

	[Subject(typeof(ScriptFile)), Tags(Categories.ResourceHandling)]
	public class When_requesting_a_minified_js_file_with_whitespace
	{
		private const string ScriptName = "formatting1.js";
		private static readonly string scriptPath = Utilities.GetScriptPath(ScriptName);
		private static string contents;
		private static ScriptFile proc;

		private Establish ctx = () =>
		{
			Utilities.ClearTemporaryDirectory();
			var tempDirectory = Utilities.MapPath(Configuration.Current.TemporaryDirectory);
			if (Directory.Exists(tempDirectory))
				Directory.Delete(tempDirectory, true);

			proc = new ScriptFile(scriptPath, ScriptName, Utilities.MapPath);
			proc.DebugModeOn = true;
		};

		private Because of = () => contents = proc.Content;

		private It Should_remove_whitespace_and_comments = () => contents.ShouldEqual("var rAnimate={isBusy:!1,Move:{}}");
	}

	[Subject(typeof(ScriptFile)), Tags(Categories.ResourceHandling)]
	public class When_requesting_a_non_minified_empty_js_file
	{
		private const string ScriptName = "empty.js";
		private static readonly string scriptPath = Utilities.GetScriptPath(ScriptName);
		private static string contents;
		private static ScriptFile proc;

		private Establish ctx = () =>
		{
			Utilities.ClearTemporaryDirectory();

			proc = new ScriptFile(scriptPath, ScriptName, Utilities.MapPath);
			proc.DebugModeOn = true;
		};

		private Because of = () => contents = proc.Content;

		private It Should_not_be_null_or_throw_an_error = () => contents.ShouldNotBeNull();
	}
}
